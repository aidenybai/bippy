---
title: Examples
description: Real-world examples of using Bippy
---

# Examples

The best way to understand Bippy is to [read the source code](https://github.com/aidenybai/bippy/blob/main/src/core.ts). Here are some examples of how you can use it:

## A Mini React-Scan

Here's a mini toy version of [`react-scan`](https://github.com/aidenybai/react-scan) that highlights renders in your app.

```javascript
import {
  instrument,
  isHostFiber,
  getNearestHostFiber,
  traverseRenderedFibers,
} from 'bippy'; // must be imported BEFORE react

const highlightFiber = (fiber) => {
  if (!(fiber.stateNode instanceof HTMLElement)) return;
  // fiber.stateNode is a DOM element
  const rect = fiber.stateNode.getBoundingClientRect();
  const highlight = document.createElement('div');
  highlight.style.border = '1px solid red';
  highlight.style.position = 'fixed';
  highlight.style.top = `${rect.top}px`;
  highlight.style.left = `${rect.left}px`;
  highlight.style.width = `${rect.width}px`;
  highlight.style.height = `${rect.height}px`;
  highlight.style.zIndex = 999999999;
  document.documentElement.appendChild(highlight);
  setTimeout(() => {
    document.documentElement.removeChild(highlight);
  }, 100);
};

/**
 * `instrument` is a function that installs the react DevTools global
 * hook and allows you to set up custom handlers for react fiber events.
 */
instrument(
  /**
   * `secure` is a function that wraps your handlers in a try/catch
   * and prevents it from crashing the app. it also prevents it from
   * running on unsupported react versions and during production.
   *
   * this is not required but highly recommended to provide "safeguards"
   * in case something breaks.
   */
  secure({
    /**
     * `onCommitFiberRoot` is a handler that is called when react is
     * ready to commit a fiber root. this means that react is has
     * rendered your entire app and is ready to apply changes to
     * the host tree (e.g. via DOM mutations).
     */
    onCommitFiberRoot(rendererID, root) {
      /**
       * `traverseRenderedFibers` traverses the fiber tree and determines which
       * fibers have actually rendered.
       *
       * A fiber tree contains many fibers that may have not rendered. this
       * can be because it bailed out (e.g. `useMemo`) or because it wasn't
       * actually rendered (if <Child> re-rendered, then <Parent> didn't
       * actually render, but exists in the fiber tree).
       */
      traverseRenderedFibers(root, (fiber) => {
        /**
         * `getNearestHostFiber` is a utility function that finds the
         * nearest host fiber to a given fiber.
         *
         * a host fiber for `react-dom` is a fiber that has a DOM element
         * as its `stateNode`.
         */
        const hostFiber = getNearestHostFiber(fiber);
        highlightFiber(hostFiber);
      });
    },
  })
);
```

## A Mini Why-Did-You-Render

Here's a mini toy version of [`why-did-you-render`](https://github.com/welldone-software/why-did-you-render) that logs why components re-render.

```typescript
import {
  instrument,
  isHostFiber,
  traverseRenderedFibers,
  isCompositeFiber,
  getDisplayName,
  traverseProps,
  traverseContexts,
  traverseState,
} from 'bippy'; // must be imported BEFORE react

instrument(
  secure({
    onCommitFiberRoot(rendererID, root) {
      traverseRenderedFibers(root, (fiber) => {
        /**
         * `isCompositeFiber` is a utility function that checks if a fiber is a composite fiber.
         * a composite fiber is a fiber that represents a function or class component.
         */
        if (!isCompositeFiber(fiber)) return;

        /**
         * `getDisplayName` is a utility function that gets the display name of a fiber.
         */
        const displayName = getDisplayName(fiber);
        if (!displayName) return;

        const changes = [];

        /**
         * `traverseProps` is a utility function that traverses the props of a fiber.
         */
        traverseProps(fiber, (propName, next, prev) => {
          if (next !== prev) {
            changes.push({
              name: `prop ${propName}`,
              prev,
              next,
            });
          }
        });

        let contextId = 0;
        /**
         * `traverseContexts` is a utility function that traverses the contexts of a fiber.
         * Contexts don't have a "name" like props, so we use an id to identify them.
         */
        traverseContexts(fiber, (next, prev) => {
          if (next !== prev) {
            changes.push({
              name: `context ${contextId}`,
              prev,
              next,
              contextId,
            });
          }
          contextId++;
        });

        let stateId = 0;
        /**
         * `traverseState` is a utility function that traverses the state of a fiber.
         *
         * State don't have a "name" like props, so we use an id to identify them.
         */
        traverseState(fiber, (next, prev) => {
          if (next !== prev) {
            changes.push({
              name: `state ${stateId}`,
              prev,
              next,
            });
          }
          stateId++;
        });

        console.group(
          `%c${displayName}`,
          'background: hsla(0,0%,70%,.3); border-radius:3px; padding: 0 2px;'
        );
        for (const { name, prev, next } of changes) {
          console.log(`${name}:`, prev, '!==', next);
        }
        console.groupEnd();
      });
    },
  })
);
```
